<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>NuPIC: Encoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="numenta-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">NuPIC
   &#160;<span id="projectnumber">0.2.7.dev0</span>
   </div>
   <div id="projectbrief">Numenta Platform for Intelligent Computing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nupic</b></li><li class="navelem"><b>encoders</b></li><li class="navelem"><b>base</b></li><li class="navelem"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html">Encoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnupic_1_1encoders_1_1base_1_1_encoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Encoder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An encoder converts a value to a sparse distributed representation.  
 <a href="classnupic_1_1encoders_1_1base_1_1_encoder.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Encoder:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classnupic_1_1encoders_1_1base_1_1_encoder.png" usemap="#Encoder_map" alt=""/>
  <map id="Encoder_map" name="Encoder_map">
<area href="classnupic_1_1encoders_1_1category_1_1_category_encoder.html" title="Encodes a list of discrete categories (described by strings), that aren&#39;t related to each other..." alt="CategoryEncoder" shape="rect" coords="212,56,414,80"/>
<area href="classnupic_1_1encoders_1_1coordinate_1_1_coordinate_encoder.html" title="Given a coordinate in an N-dimensional space, and a radius around that coordinate, the Coordinate Encoder returns an SDR representation of that position." alt="CoordinateEncoder" shape="rect" coords="212,112,414,136"/>
<area href="classnupic_1_1encoders_1_1date_1_1_date_encoder.html" title="A date encoder encodes a date according to encoding parameters specified in its constructor." alt="DateEncoder" shape="rect" coords="212,168,414,192"/>
<area href="classnupic_1_1encoders_1_1logenc_1_1_log_encoder.html" title="This class wraps the ScalarEncoder class." alt="LogEncoder" shape="rect" coords="212,224,414,248"/>
<area href="classnupic_1_1encoders_1_1multi_1_1_multi_encoder.html" title="A MultiEncoder encodes a dictionary or object with multiple components." alt="MultiEncoder" shape="rect" coords="212,280,414,304"/>
<area href="classnupic_1_1encoders_1_1pass__through__encoder_1_1_pass_through_encoder.html" title="Pass an encoded SDR straight to the model." alt="PassThroughEncoder" shape="rect" coords="212,336,414,360"/>
<area href="classnupic_1_1encoders_1_1random__distributed__scalar_1_1_random_distributed_scalar_encoder.html" title="A scalar encoder encodes a numeric (floating point) value into an array of bits." alt="RandomDistributedScalarEncoder" shape="rect" coords="212,392,414,416"/>
<area href="classnupic_1_1encoders_1_1scalar_1_1_scalar_encoder.html" title="A scalar encoder encodes a numeric (floating point) value into an array of bits." alt="ScalarEncoder" shape="rect" coords="212,448,414,472"/>
<area href="classnupic_1_1encoders_1_1scalarspace_1_1_scalar_space_encoder.html" title="An encoder that can be used to permute the encodings through different spaces These include absolute ..." alt="ScalarSpaceEncoder" shape="rect" coords="212,504,414,528"/>
<area href="classnupic_1_1encoders_1_1sdrcategory_1_1_s_d_r_category_encoder.html" title="Encodes a list of discrete categories (described by strings), that aren&#39;t related to each other..." alt="SDRCategoryEncoder" shape="rect" coords="212,560,414,584"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc3815f30266aa8dca6e568755c30002"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#adc3815f30266aa8dca6e568755c30002">getWidth</a></td></tr>
<tr class="memdesc:adc3815f30266aa8dca6e568755c30002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should return the output width, in bits.  <a href="#adc3815f30266aa8dca6e568755c30002">More...</a><br/></td></tr>
<tr class="separator:adc3815f30266aa8dca6e568755c30002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa42f8270b57813993a952c9f9809888"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#afa42f8270b57813993a952c9f9809888">encodeIntoArray</a></td></tr>
<tr class="memdesc:afa42f8270b57813993a952c9f9809888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes inputData and puts the encoded value into the numpy output array, which is a 1-D array of length returned by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#adc3815f30266aa8dca6e568755c30002" title="Should return the output width, in bits.">getWidth()</a>.  <a href="#afa42f8270b57813993a952c9f9809888">More...</a><br/></td></tr>
<tr class="separator:afa42f8270b57813993a952c9f9809888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e68fd9b22094e51283f067cebc015"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a5f5e68fd9b22094e51283f067cebc015">setLearning</a></td></tr>
<tr class="memdesc:a5f5e68fd9b22094e51283f067cebc015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether learning is enabled.  <a href="#a5f5e68fd9b22094e51283f067cebc015">More...</a><br/></td></tr>
<tr class="separator:a5f5e68fd9b22094e51283f067cebc015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c67b9a919881fec9d9d8d5a97676ac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa5c67b9a919881fec9d9d8d5a97676ac">setFieldStats</a></td></tr>
<tr class="memdesc:aa5c67b9a919881fec9d9d8d5a97676ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by the model to set the statistics like min and max for the underlying encoders if this information is available.  <a href="#aa5c67b9a919881fec9d9d8d5a97676ac">More...</a><br/></td></tr>
<tr class="separator:aa5c67b9a919881fec9d9d8d5a97676ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079d592aa5360c10d39d8e7b98b9b0de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a079d592aa5360c10d39d8e7b98b9b0de">encode</a></td></tr>
<tr class="memdesc:a079d592aa5360c10d39d8e7b98b9b0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for encodeIntoArray.  <a href="#a079d592aa5360c10d39d8e7b98b9b0de">More...</a><br/></td></tr>
<tr class="separator:a079d592aa5360c10d39d8e7b98b9b0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d5d6beb1401f27d529defd09a86ecf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa3d5d6beb1401f27d529defd09a86ecf">getScalarNames</a></td></tr>
<tr class="memdesc:aa3d5d6beb1401f27d529defd09a86ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the field names for each of the scalar values returned by getScalars.  <a href="#aa3d5d6beb1401f27d529defd09a86ecf">More...</a><br/></td></tr>
<tr class="separator:aa3d5d6beb1401f27d529defd09a86ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c1f94ffd2fe55c8d52935e7a66f068"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a01c1f94ffd2fe55c8d52935e7a66f068">getDecoderOutputFieldTypes</a></td></tr>
<tr class="memdesc:a01c1f94ffd2fe55c8d52935e7a66f068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sequence of field types corresponding to the elements in the decoded output field array.  <a href="#a01c1f94ffd2fe55c8d52935e7a66f068">More...</a><br/></td></tr>
<tr class="separator:a01c1f94ffd2fe55c8d52935e7a66f068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb3c1dac43f3e7cefe5e1ad577172b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aacb3c1dac43f3e7cefe5e1ad577172b0">setStateLock</a></td></tr>
<tr class="memdesc:aacb3c1dac43f3e7cefe5e1ad577172b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting this to true freezes the state of the encoder This is separate from the learning state which affects changing parameters.  <a href="#aacb3c1dac43f3e7cefe5e1ad577172b0">More...</a><br/></td></tr>
<tr class="separator:aacb3c1dac43f3e7cefe5e1ad577172b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277b2c1f00908e7ce261f9e79406e34f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a277b2c1f00908e7ce261f9e79406e34f">getEncoderList</a></td></tr>
<tr class="separator:a277b2c1f00908e7ce261f9e79406e34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da1330a12c78a3e527ace5745d28918"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a6da1330a12c78a3e527ace5745d28918">getScalars</a></td></tr>
<tr class="memdesc:a6da1330a12c78a3e527ace5745d28918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a numpy array containing the sub-field scalar value(s) for each sub-field of the inputData.  <a href="#a6da1330a12c78a3e527ace5745d28918">More...</a><br/></td></tr>
<tr class="separator:a6da1330a12c78a3e527ace5745d28918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0629eda853580c07b4176d68ebaedbfd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a0629eda853580c07b4176d68ebaedbfd">getEncodedValues</a></td></tr>
<tr class="memdesc:a0629eda853580c07b4176d68ebaedbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input in the same format as is returned by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a39c4d54611adb4ddf6b3a93662fa70f3" title="Returns a list of EncoderResult namedtuples describing the top-down best guess inputs for each sub-fi...">topDownCompute()</a>.  <a href="#a0629eda853580c07b4176d68ebaedbfd">More...</a><br/></td></tr>
<tr class="separator:a0629eda853580c07b4176d68ebaedbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0cb94c740da809b42974bc52c019fa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a0a0cb94c740da809b42974bc52c019fa">getBucketIndices</a></td></tr>
<tr class="memdesc:a0a0cb94c740da809b42974bc52c019fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array containing the sub-field bucket indices for each sub-field of the inputData.  <a href="#a0a0cb94c740da809b42974bc52c019fa">More...</a><br/></td></tr>
<tr class="separator:a0a0cb94c740da809b42974bc52c019fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f8a584a6282b6be150f53a23fcc6a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a21f8a584a6282b6be150f53a23fcc6a0">scalarsToStr</a></td></tr>
<tr class="memdesc:a21f8a584a6282b6be150f53a23fcc6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pretty print string representing the return values from getScalars and <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa3d5d6beb1401f27d529defd09a86ecf" title="Return the field names for each of the scalar values returned by getScalars.">getScalarNames()</a>.  <a href="#a21f8a584a6282b6be150f53a23fcc6a0">More...</a><br/></td></tr>
<tr class="separator:a21f8a584a6282b6be150f53a23fcc6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddb818fc1af9fb1e56a22c5d22e2ee1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aeddb818fc1af9fb1e56a22c5d22e2ee1">getDescription</a></td></tr>
<tr class="memdesc:aeddb818fc1af9fb1e56a22c5d22e2ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a list of tuples, each containing (name, offset).  <a href="#aeddb818fc1af9fb1e56a22c5d22e2ee1">More...</a><br/></td></tr>
<tr class="separator:aeddb818fc1af9fb1e56a22c5d22e2ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af325221758171a9fa6c8068d4c566ef5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#af325221758171a9fa6c8068d4c566ef5">getFieldDescription</a></td></tr>
<tr class="memdesc:af325221758171a9fa6c8068d4c566ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset and length of a given field within the encoded output.  <a href="#af325221758171a9fa6c8068d4c566ef5">More...</a><br/></td></tr>
<tr class="separator:af325221758171a9fa6c8068d4c566ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f62185ac0d79c273eb28b72e27ef55"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a16f62185ac0d79c273eb28b72e27ef55">encodedBitDescription</a></td></tr>
<tr class="memdesc:a16f62185ac0d79c273eb28b72e27ef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a description of the given bit in the encoded output.  <a href="#a16f62185ac0d79c273eb28b72e27ef55">More...</a><br/></td></tr>
<tr class="separator:a16f62185ac0d79c273eb28b72e27ef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aae9449a811745c57bb9a87ebe7215b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a8aae9449a811745c57bb9a87ebe7215b">pprintHeader</a></td></tr>
<tr class="memdesc:a8aae9449a811745c57bb9a87ebe7215b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-print a header that labels the sub-fields of the encoded output.  <a href="#a8aae9449a811745c57bb9a87ebe7215b">More...</a><br/></td></tr>
<tr class="separator:a8aae9449a811745c57bb9a87ebe7215b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb788ad94cb6bab07093b1490cecb895"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#abb788ad94cb6bab07093b1490cecb895">pprint</a></td></tr>
<tr class="memdesc:abb788ad94cb6bab07093b1490cecb895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-print the encoded output using ascii art.  <a href="#abb788ad94cb6bab07093b1490cecb895">More...</a><br/></td></tr>
<tr class="separator:abb788ad94cb6bab07093b1490cecb895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbee92188b27374274e8e89960d8522"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a7cbee92188b27374274e8e89960d8522">decode</a></td></tr>
<tr class="memdesc:a7cbee92188b27374274e8e89960d8522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an encoded output and does its best to work backwards and generate the input that would have generated it.  <a href="#a7cbee92188b27374274e8e89960d8522">More...</a><br/></td></tr>
<tr class="separator:a7cbee92188b27374274e8e89960d8522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2685b0a1bc2a5108f931a4ca78c0654f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2685b0a1bc2a5108f931a4ca78c0654f"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a2685b0a1bc2a5108f931a4ca78c0654f">decodedToStr</a></td></tr>
<tr class="memdesc:a2685b0a1bc2a5108f931a4ca78c0654f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pretty print string representing the return value from <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a7cbee92188b27374274e8e89960d8522" title="Takes an encoded output and does its best to work backwards and generate the input that would have ge...">decode()</a>. <br/></td></tr>
<tr class="separator:a2685b0a1bc2a5108f931a4ca78c0654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4a79c6493042870741e5caaa6b5a63"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#add4a79c6493042870741e5caaa6b5a63">getBucketValues</a></td></tr>
<tr class="memdesc:add4a79c6493042870741e5caaa6b5a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of items, one for each bucket defined by this encoder.  <a href="#add4a79c6493042870741e5caaa6b5a63">More...</a><br/></td></tr>
<tr class="separator:add4a79c6493042870741e5caaa6b5a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ebec12ede4c61315c685dbb9d0f021"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a00ebec12ede4c61315c685dbb9d0f021">getBucketInfo</a></td></tr>
<tr class="memdesc:a00ebec12ede4c61315c685dbb9d0f021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of EncoderResult namedtuples describing the inputs for each sub-field that correspond to the bucket indices passed in 'buckets'.  <a href="#a00ebec12ede4c61315c685dbb9d0f021">More...</a><br/></td></tr>
<tr class="separator:a00ebec12ede4c61315c685dbb9d0f021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c4d54611adb4ddf6b3a93662fa70f3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a39c4d54611adb4ddf6b3a93662fa70f3">topDownCompute</a></td></tr>
<tr class="memdesc:a39c4d54611adb4ddf6b3a93662fa70f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of EncoderResult namedtuples describing the top-down best guess inputs for each sub-field given the encoded output.  <a href="#a39c4d54611adb4ddf6b3a93662fa70f3">More...</a><br/></td></tr>
<tr class="separator:a39c4d54611adb4ddf6b3a93662fa70f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40edb9ac8181ea77b137de39af90c3d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#ad40edb9ac8181ea77b137de39af90c3d">closenessScores</a></td></tr>
<tr class="memdesc:ad40edb9ac8181ea77b137de39af90c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute closeness scores between the expected scalar value(s) and actual scalar value(s).  <a href="#ad40edb9ac8181ea77b137de39af90c3d">More...</a><br/></td></tr>
<tr class="separator:ad40edb9ac8181ea77b137de39af90c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015c924b7a05b4e42e71204170756ce0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a015c924b7a05b4e42e71204170756ce0">getDisplayWidth</a></td></tr>
<tr class="memdesc:a015c924b7a05b4e42e71204170756ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate width of display for bits plus blanks between fields.  <a href="#a015c924b7a05b4e42e71204170756ce0">More...</a><br/></td></tr>
<tr class="separator:a015c924b7a05b4e42e71204170756ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fafcd2f8af6c765d3a4ea3759393406"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a9fafcd2f8af6c765d3a4ea3759393406">formatBits</a></td></tr>
<tr class="memdesc:a9fafcd2f8af6c765d3a4ea3759393406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one array to another, inserting blanks between fields (for display) If leftpad is one, then there is a dummy value at element 0 of the arrays, and we should start our counting from 1 rather than 0.  <a href="#a9fafcd2f8af6c765d3a4ea3759393406">More...</a><br/></td></tr>
<tr class="separator:a9fafcd2f8af6c765d3a4ea3759393406"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An encoder converts a value to a sparse distributed representation. </p>
<p>This is the base class for encoders that are compatible with the OPF. The OPF requires that values can be represented as a scalar value for use in places like the CLA Classifier. The <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html" title="An encoder converts a value to a sparse distributed representation.">Encoder</a> superclass implements:</p>
<ul>
<li><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a079d592aa5360c10d39d8e7b98b9b0de" title="Convenience wrapper for encodeIntoArray.">encode()</a> - returns a numpy array encoding the input; syntactic sugar on top of encodeIntoArray. If pprint, prints the encoding to the terminal</li>
<li><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a8aae9449a811745c57bb9a87ebe7215b" title="Pretty-print a header that labels the sub-fields of the encoded output.">pprintHeader()</a> - prints a header describing the encoding to the terminal</li>
<li><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#abb788ad94cb6bab07093b1490cecb895" title="Pretty-print the encoded output using ascii art.">pprint()</a> - prints an encoding to the terminal</li>
</ul>
<p>Methods/properties that must be implemented by subclasses:</p>
<ul>
<li><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a01c1f94ffd2fe55c8d52935e7a66f068" title="Returns a sequence of field types corresponding to the elements in the decoded output field array...">getDecoderOutputFieldTypes()</a> - must be implemented by leaf encoders returns [<code>nupic.data.fieldmeta.FieldMetaType.XXXXX</code>] (e.g., [nupic.data.fieldmetaFieldMetaType.float])</li>
<li><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#adc3815f30266aa8dca6e568755c30002" title="Should return the output width, in bits.">getWidth()</a> - returns the output width, in bits</li>
<li><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#afa42f8270b57813993a952c9f9809888" title="Encodes inputData and puts the encoded value into the numpy output array, which is a 1-D array of len...">encodeIntoArray()</a> - encodes input and puts the encoded value into the numpy output array, which is a 1-D array of length returned by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#adc3815f30266aa8dca6e568755c30002" title="Should return the output width, in bits.">getWidth()</a></li>
<li><a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aeddb818fc1af9fb1e56a22c5d22e2ee1" title="This returns a list of tuples, each containing (name, offset).">getDescription()</a> - returns a list of (name, offset) pairs describing the encoded output </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad40edb9ac8181ea77b137de39af90c3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def closenessScores </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>expValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>actValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fractional</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute closeness scores between the expected scalar value(s) and actual scalar value(s). </p>
<p>The expected scalar values are typically those obtained from the <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a6da1330a12c78a3e527ace5745d28918" title="Returns a numpy array containing the sub-field scalar value(s) for each sub-field of the inputData...">getScalars()</a> method. The actual scalar values are typically those returned from the <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a39c4d54611adb4ddf6b3a93662fa70f3" title="Returns a list of EncoderResult namedtuples describing the top-down best guess inputs for each sub-fi...">topDownCompute()</a> method.</p>
<p>This method returns one closeness score for each value in expValues (or actValues which must be the same length). The closeness score ranges from 0 to 1.0, 1.0 being a perfect match and 0 being the worst possible match.</p>
<p>If this encoder is a simple, single field encoder, then it will expect just 1 item in each of the expValues and actValues arrays. Multi-encoders will expect 1 item per sub-encoder.</p>
<p>Each encoder type can define it's own metric for closeness. For example, a category encoder may return either 1 or 0, if the scalar matches exactly or not. A scalar encoder might return a percentage match, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expValues</td><td>Array of expected scalar values, typically obtained from <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a6da1330a12c78a3e527ace5745d28918" title="Returns a numpy array containing the sub-field scalar value(s) for each sub-field of the inputData...">getScalars()</a> </td></tr>
    <tr><td class="paramname">actValues</td><td>Array of actual values, typically obtained from <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a39c4d54611adb4ddf6b3a93662fa70f3" title="Returns a list of EncoderResult namedtuples describing the top-down best guess inputs for each sub-fi...">topDownCompute()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of closeness scores, one per item in expValues (or actValues). </dd></dl>

</div>
</div>
<a class="anchor" id="a7cbee92188b27374274e8e89960d8522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def decode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parentFieldName</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes an encoded output and does its best to work backwards and generate the input that would have generated it. </p>
<pre class="fragment"> In cases where the encoded output contains more ON bits than an input
 would have generated, this routine will return one or more ranges of inputs
 which, if their encoded outputs were ORed together, would produce the
 target output. This behavior makes this method suitable for doing things
 like generating a description of a learned coincidence in the SP, which
 in many cases might be a union of one or more inputs.

 If instead, you want to figure the *most likely* single input scalar value
 that would have generated a specific encoded output, use the topDownCompute()
 method.

 If you want to pretty print the return value from this method, use the
 decodedToStr() method.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoded</td><td>The encoded output that you want decode </td></tr>
    <tr><td class="paramname">parentFieldName</td><td>The name of the encoder which is our parent. This name is prefixed to each of the field names within this encoder to form the keys of the dict() in the retval.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple(fieldsDict, fieldOrder) (see below for details) <pre class="fragment"> fieldsDict is a dict() where the keys represent field names
 (only 1 if this is a simple encoder, &gt; 1 if this is a multi
 or date encoder) and the values are the result of decoding each
 field. If there are  no bits in encoded that would have been
 generated by a field, it won't be present in the dict. The
 key of each entry in the dict is formed by joining the passed in
 parentFieldName with the child encoder name using a '.'.

 Each 'value' in fieldsDict consists of (ranges, desc), where
 ranges is a list of one or more (minVal, maxVal) ranges of
 input that would generate bits in the encoded output and 'desc'
 is a pretty print description of the ranges. For encoders like
 the category encoder, the 'desc' will contain the category
 names that correspond to the scalar values included in the
 ranges.

 The fieldOrder is a list of the keys from fieldsDict, in the
 same order as the fields appear in the encoded output.

 TODO: when we switch to Python 2.7 or 3.x, use OrderedDict

 Example retvals for a scalar encoder:

     {'amount':  ( [[1,3], [7,10]], '1-3, 7-10' )}
     {'amount':  ( [[2.5,2.5]],     '2.5'       )}

 Example retval for a category encoder:

     {'country': ( [[1,1], [5,6]], 'US, GB, ES' )}

 Example retval for a multi encoder:

     {'amount':  ( [[2.5,2.5]],     '2.5'       ),
      'country': ( [[1,1], [5,6]],  'US, GB, ES' )}</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="a079d592aa5360c10d39d8e7b98b9b0de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def encode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience wrapper for encodeIntoArray. </p>
<pre class="fragment"> This may be less efficient because it allocates a new numpy array every
 call.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputData</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a numpy array with the encoded representation of inputData </dd></dl>

</div>
</div>
<a class="anchor" id="a16f62185ac0d79c273eb28b72e27ef55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def encodedBitDescription </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bitOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>formatted</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a description of the given bit in the encoded output. </p>
<pre class="fragment"> This will include the field name and the offset within the field.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitOffset</td><td>Offset of the bit to get the description of </td></tr>
    <tr><td class="paramname">formatted</td><td>If True, the bitOffset is w.r.t. formatted output, which includes separators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple(fieldName, offsetWithinField) </dd></dl>

</div>
</div>
<a class="anchor" id="afa42f8270b57813993a952c9f9809888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def encodeIntoArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes inputData and puts the encoded value into the numpy output array, which is a 1-D array of length returned by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#adc3815f30266aa8dca6e568755c30002" title="Should return the output width, in bits.">getWidth()</a>. </p>
<pre class="fragment"> Note: The numpy output array is reused, so clear it before updating it.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputData</td><td>Data to encode. This should be validated by the encoder. </td></tr>
    <tr><td class="paramname">output</td><td>numpy 1-D array of same length returned by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#adc3815f30266aa8dca6e568755c30002" title="Should return the output width, in bits.">getWidth()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fafcd2f8af6c765d3a4ea3759393406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def formatBits </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blank</em> = <code>255</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leftpad</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy one array to another, inserting blanks between fields (for display) If leftpad is one, then there is a dummy value at element 0 of the arrays, and we should start our counting from 1 rather than 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inarray</td><td>TODO: document </td></tr>
    <tr><td class="paramname">outarray</td><td>TODO: document </td></tr>
    <tr><td class="paramname">scale</td><td>TODO: document </td></tr>
    <tr><td class="paramname">blank</td><td>TODO: document </td></tr>
    <tr><td class="paramname">leftpad</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a0cb94c740da809b42974bc52c019fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getBucketIndices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array containing the sub-field bucket indices for each sub-field of the inputData. </p>
<p>To get the associated field names for each of the buckets, call <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa3d5d6beb1401f27d529defd09a86ecf" title="Return the field names for each of the scalar values returned by getScalars.">getScalarNames()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputData</td><td>The data from the source. This is typically a object with members. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of bucket indices </dd></dl>

</div>
</div>
<a class="anchor" id="a00ebec12ede4c61315c685dbb9d0f021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getBucketInfo </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>buckets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of EncoderResult namedtuples describing the inputs for each sub-field that correspond to the bucket indices passed in 'buckets'. </p>
<pre class="fragment"> To get the associated field names for each of the values, call getScalarNames().
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buckets</td><td>The list of bucket indices, one for each sub-field encoder. These bucket indices for example may have been retrieved from the <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a0a0cb94c740da809b42974bc52c019fa" title="Returns an array containing the sub-field bucket indices for each sub-field of the inputData...">getBucketIndices()</a> call.  A list of EncoderResult namedtuples. Each EncoderResult has three attributes:</td></tr>
  </table>
  </dd>
</dl>
<ol type="1">
<li>value: This is the value for the sub-field in a format that is consistent with the type specified by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a01c1f94ffd2fe55c8d52935e7a66f068" title="Returns a sequence of field types corresponding to the elements in the decoded output field array...">getDecoderOutputFieldTypes()</a>. Note that this value is not necessarily numeric.</li>
<li>scalar: The scalar representation of value. This number is consistent with what is returned by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a6da1330a12c78a3e527ace5745d28918" title="Returns a numpy array containing the sub-field scalar value(s) for each sub-field of the inputData...">getScalars()</a>. This value is always an int or float, and can be used for numeric comparisons</li>
<li>encoding This is the encoded bit-array (numpy array) that represents 'value'. That is, if 'value' was passed to <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a079d592aa5360c10d39d8e7b98b9b0de" title="Convenience wrapper for encodeIntoArray.">encode()</a>, an identical bit-array should be returned </li>
</ol>

</div>
</div>
<a class="anchor" id="add4a79c6493042870741e5caaa6b5a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getBucketValues </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of items, one for each bucket defined by this encoder. </p>
<pre class="fragment"> Each item is the value assigned to that bucket, this is the same as the
 EncoderResult.value that would be returned by getBucketInfo() for that
 bucket and is in the same format as the input that would be passed to
 encode().

 This call is faster than calling getBucketInfo() on each bucket individually
 if all you need are the bucket values.

 **Must be overridden by subclasses.**
</pre><dl class="section return"><dt>Returns</dt><dd>list of items, each item representing the bucket value for that bucket. </dd></dl>

</div>
</div>
<a class="anchor" id="a01c1f94ffd2fe55c8d52935e7a66f068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getDecoderOutputFieldTypes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sequence of field types corresponding to the elements in the decoded output field array. </p>
<p>The types are defined by nupic.data.fieldmeta.FieldMetaType.</p>
<dl class="section return"><dt>Returns</dt><dd>list of nupic.data.fieldmeta.FieldMetaType objects </dd></dl>

</div>
</div>
<a class="anchor" id="aeddb818fc1af9fb1e56a22c5d22e2ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getDescription </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a list of tuples, each containing (name, offset). </p>
<pre class="fragment"> The 'name' is a string description of each sub-field, and offset is the bit
 offset of the sub-field for that encoder.

 For now, only the 'multi' and 'date' encoders have multiple (name, offset)
 pairs. All other encoders have a single pair, where the offset is 0.

 **Must be overridden by subclasses.**
</pre><dl class="section return"><dt>Returns</dt><dd>list of tuples containing (name, offset) </dd></dl>

</div>
</div>
<a class="anchor" id="a015c924b7a05b4e42e71204170756ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getDisplayWidth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate width of display for bits plus blanks between fields. </p>
<dl class="section return"><dt>Returns</dt><dd>width of display for bits plus blanks between fields </dd></dl>

</div>
</div>
<a class="anchor" id="a0629eda853580c07b4176d68ebaedbfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getEncodedValues </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the input in the same format as is returned by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a39c4d54611adb4ddf6b3a93662fa70f3" title="Returns a list of EncoderResult namedtuples describing the top-down best guess inputs for each sub-fi...">topDownCompute()</a>. </p>
<pre class="fragment"> For most encoder types, this is the same as the input data.
 For instance, for scalar and category types, this corresponds to the numeric
 and string values, respectively, from the inputs. For datetime encoders, this
 returns the list of scalars for each of the sub-fields (timeOfDay, dayOfWeek, etc.)

 This method is essentially the same as getScalars() except that it returns
 strings
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputData</td><td>The input data in the format it is received from the data source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of values, in the same format and in the same order as they are returned by topDownCompute. </dd></dl>

</div>
</div>
<a class="anchor" id="a277b2c1f00908e7ce261f9e79406e34f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getEncoderList </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to each sub-encoder in this encoder. They are returned in the same order as they are for <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa3d5d6beb1401f27d529defd09a86ecf" title="Return the field names for each of the scalar values returned by getScalars.">getScalarNames()</a> and <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a6da1330a12c78a3e527ace5745d28918" title="Returns a numpy array containing the sub-field scalar value(s) for each sub-field of the inputData...">getScalars()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af325221758171a9fa6c8068d4c566ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getFieldDescription </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the offset and length of a given field within the encoded output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>Name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple(offset, width) of the field within the encoded output </dd></dl>

</div>
</div>
<a class="anchor" id="aa3d5d6beb1401f27d529defd09a86ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getScalarNames </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parentFieldName</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the field names for each of the scalar values returned by getScalars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentFieldName</td><td>The name of the encoder which is our parent. This name is prefixed to each of the field names within this encoder to form the keys of the dict() in the retval.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of field names </dd></dl>

</div>
</div>
<a class="anchor" id="a6da1330a12c78a3e527ace5745d28918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getScalars </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a numpy array containing the sub-field scalar value(s) for each sub-field of the inputData. </p>
<p>To get the associated field names for each of the scalar values, call <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa3d5d6beb1401f27d529defd09a86ecf" title="Return the field names for each of the scalar values returned by getScalars.">getScalarNames()</a>.</p>
<p>For a simple scalar encoder, the scalar value is simply the input unmodified. For category encoders, it is the scalar representing the category string that is passed in. For the datetime encoder, the scalar value is the the number of seconds since epoch.</p>
<p>The intent of the scalar representation of a sub-field is to provide a baseline for measuring error differences. You can compare the scalar value of the inputData with the scalar value returned from <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a39c4d54611adb4ddf6b3a93662fa70f3" title="Returns a list of EncoderResult namedtuples describing the top-down best guess inputs for each sub-fi...">topDownCompute()</a> on a top-down representation to evaluate prediction accuracy, for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputData</td><td>The data from the source. This is typically a object with members </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of scalar values </dd></dl>

</div>
</div>
<a class="anchor" id="adc3815f30266aa8dca6e568755c30002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getWidth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should return the output width, in bits. </p>
<dl class="section return"><dt>Returns</dt><dd>output width in bits </dd></dl>

</div>
</div>
<a class="anchor" id="abb788ad94cb6bab07093b1490cecb895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pprint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty-print the encoded output using ascii art. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>to print </td></tr>
    <tr><td class="paramname">prefix</td><td>printed before the header if specified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8aae9449a811745c57bb9a87ebe7215b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pprintHeader </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty-print a header that labels the sub-fields of the encoded output. </p>
<p>This can be used in conjuction with pprint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>printed before the header if specified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21f8a584a6282b6be150f53a23fcc6a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def scalarsToStr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scalarValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scalarNames</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pretty print string representing the return values from getScalars and <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa3d5d6beb1401f27d529defd09a86ecf" title="Return the field names for each of the scalar values returned by getScalars.">getScalarNames()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalarValues</td><td>input values to encode to string </td></tr>
    <tr><td class="paramname">scalarNames</td><td>optional input of scalar names to convert. If None, gets scalar names from <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa3d5d6beb1401f27d529defd09a86ecf" title="Return the field names for each of the scalar values returned by getScalars.">getScalarNames()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representation of scalar values </dd></dl>

</div>
</div>
<a class="anchor" id="aa5c67b9a919881fec9d9d8d5a97676ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setFieldStats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fieldStatistics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is called by the model to set the statistics like min and max for the underlying encoders if this information is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field this encoder is encoding, provided by multiencoder</td></tr>
    <tr><td class="paramname">fieldStatistics</td><td>dictionary of dictionaries with the first level being the fieldname and the second index the statistic ie: fieldStatistics['pounds']['min'] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f5e68fd9b22094e51283f067cebc015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setLearning </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>learningEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether learning is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">learningEnabled</td><td>whether learning should be enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacb3c1dac43f3e7cefe5e1ad577172b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setStateLock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting this to true freezes the state of the encoder This is separate from the learning state which affects changing parameters. </p>
<p>Implemented in subclasses. </p>

</div>
</div>
<a class="anchor" id="a39c4d54611adb4ddf6b3a93662fa70f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def topDownCompute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of EncoderResult namedtuples describing the top-down best guess inputs for each sub-field given the encoded output. </p>
<p>These are the values which are most likely to generate the given encoded output. To get the associated field names for each of the values, call <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#aa3d5d6beb1401f27d529defd09a86ecf" title="Return the field names for each of the scalar values returned by getScalars.">getScalarNames()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoded</td><td>The encoded output. Typically received from the topDown outputs from the spatial pooler just above us.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of EncoderResult namedtuples. Each EncoderResult has three attributes:</dd></dl>
<ol type="1">
<li>value: This is the best-guess value for the sub-field in a format that is consistent with the type specified by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a01c1f94ffd2fe55c8d52935e7a66f068" title="Returns a sequence of field types corresponding to the elements in the decoded output field array...">getDecoderOutputFieldTypes()</a>. Note that this value is not necessarily numeric.</li>
</ol>
<ol type="1">
<li>scalar: The scalar representation of this best-guess value. This number is consistent with what is returned by <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a6da1330a12c78a3e527ace5745d28918" title="Returns a numpy array containing the sub-field scalar value(s) for each sub-field of the inputData...">getScalars()</a>. This value is always an int or float, and can be used for numeric comparisons.</li>
</ol>
<ol type="1">
<li>encoding This is the encoded bit-array (numpy array) that represents the best-guess value. That is, if 'value' was passed to <a class="el" href="classnupic_1_1encoders_1_1base_1_1_encoder.html#a079d592aa5360c10d39d8e7b98b9b0de" title="Convenience wrapper for encodeIntoArray.">encode()</a>, an identical bit-array should be returned. </li>
</ol>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>nupic/encoders/base.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 14 2015 09:29:08 for NuPIC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
